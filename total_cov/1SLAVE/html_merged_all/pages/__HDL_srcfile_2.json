var g_sourceLines = [
'//-------------------------------------------------------',
'//tb.sv',
'//--------------------------------------------------------',
'`include "./uvm_list.svh"',
'module tb;',
'    //----------------------------------------',
'    //host signals',
'    //----------------------------------------',
'    reg clk_tb;',
'    //',
'    //gen clk',
'    //	',
'  initial begin',
'    clk_tb = 0;',
'    forever #(`CLK_CYCLE/2) clk_tb = ~clk_tb;',
'  end',
'  //',
'    //----------------------------------------',
'    //instantiate interface pin',
'    //----------------------------------------',
'  axi_intf #(DW, AW1) AXI(clk_tb); //lack of symbol "()" causes error',
'  apb_intf #(DW, AW2) APB(clk_tb);',
'  //',
'  assign APB.presetn = AXI.aresetn;',
'  //----------------------------------------',
'  //instantiate DUT interface',
'  //----------------------------------------',
'  x2p_top dut_top (',
'  //global signals',
'  .aclk(AXI.aclk),',
'  .aresetn(AXI.aresetn),',
'  //write addr channel',
'  .awid(AXI.awid),       //MSB is fixed',
'  .awvalid(AXI.awvalid),',
'  .awaddr(AXI.awaddr),   //2 bit used for handling byte, halfword, word',
'  .awlen(AXI.awlen),     //a number of transfers in one burst, possible 8-bit width',
'  .awsize(AXI.awsize),    //000: byte, 001: half word, 010: word, etc',
'  .awburst(AXI.awburst),    //00: fixed, 01: incr, 10: wrap, 11:reserved',
'  .awprot(AXI.awprot),',
'  .awready(AXI.awready),',
'',
'  //write data channel',
'  .wvalid(AXI.wvalid),',
'  .wlast(AXI.wlast),',
'  .wdata(AXI.wdata),',
'  .wstrb(AXI.wstrb),      //used for unaligned address',
'  .wready(AXI.wready),',
'',
'  //write response channel',
'  .bready(AXI.bready),',
'  .bvalid(AXI.bvalid),',
'  .bid(AXI.bid),       //must match awid signal',
'  .bresp(AXI.bresp),     //OKAY, EXOKAY, SLVERR, DECERR',
'',
'  //read addr channel',
'  .araddr(AXI.araddr),     //2 bit used for handling byte, halfword, word',
'  .arid(AXI.arid),',
'  .arsize(AXI.arsize),',
'  .arlen(AXI.arlen),',
'  .arburst(AXI.arburst),',
'  .arprot(AXI.arprot),',
'  .arvalid(AXI.arvalid),',
'  .arready(AXI.arready),',
'',
'  //read data channel',
'  .rdata(AXI.rdata),',
'  .rresp(AXI.rresp),         //OKAY, EXOKAY, SLVERR, DECERR',
'  .rid(AXI.rid),           //must match arid signal',
'  .rlast(AXI.rlast),',
'  .rvalid(AXI.rvalid),',
'  .rready(AXI.rready),        //',
'',
'  //APB Interface',
'  .pclk(APB.pclk)       , ',
'  .preset_n(APB.presetn),',
'  .pprot(APB.pprot),',
'  .pready(APB.pready)   ,',
'  .pslverr(APB.pslverr) ,',
'  .psel(APB.psel)	      ,',
'  .penable(APB.penable) ,',
'  .pwrite(APB.pwrite)	  ,',
'  .pstrb(APB.pstrb)	    ,',
'  .paddr(APB.paddr)		  ,',
'  .pwdata(APB.pwdata)   ,',
'  .prdata(APB.prdata)	    ',
'  //',
');',
'',
'  //functional coverage',
'  axi_cov_top axi_cov_top();',
'  //SET virtual interface ',
'  initial begin',
'    //context (null or this class), detailed path, field name in detailed path, variable to store in this context) ',
'    uvm_config_db#(virtual interface axi_intf #(DW, AW1))::set(null, "uvm_test_top", "m_vif", AXI);',
'    uvm_config_db#(virtual interface apb_intf #(DW, AW2))::set(null, "uvm_test_top", "s_vif", APB);',
'end',
'   //',
'   initial begin',
'    run_test();',
'   end ',
'endmodule',
''
];
countinueBuildStmtTable(g_sourceLines);
