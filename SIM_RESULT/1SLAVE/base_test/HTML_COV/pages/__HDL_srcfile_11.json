var g_sourceLines = [
'//',
'//',
'//',
'module apb_master(',
'	pclk,',
'	preset_n,',
'	//',
'	//control signal',
'	//',
'	trans_go_i,',
'	next_transfer_rdy_i,',
'	end_of_burst_i,',
'	grant_to_write_i,',
'	wstrb_to_apb_i,	',
'	wdata_to_apb_i,	',
'	start_addr_i,',
'	len_of_burst_i,',
'	size_of_transfer_i,',
'	used_burst_i,',
'	used_prot_i,',
'	//APB interface',
'	paddr,',
'	pprot,',
'	psel,',
'	penable,',
'	pwrite,',
'	pwdata,',
'	pstrb,',
'	pready,',
'	prdata,',
'	pslverr,',
'//send to AXI transaction controller',
'	prdataX_o,',
'	pslverrX_o,',
'	//control outputs',
'	write_to_rd_sfifo_o,',
'	read_from_wd_sfifo_o,',
'	set_up_phase_o,',
'	beat_cnt_incr_o,',
'	dec_error_o,',
'	latch_resp_o',
'	//',
'	//',
'	//',
');',
'//*********************************************************',
'//PORTS',
'//*********************************************************',
'input logic                    pclk;',
'input logic                    preset_n;',
'//',
'input logic trans_go_i;',
'input logic next_transfer_rdy_i;',
'input logic end_of_burst_i;',
'input logic grant_to_write_i;',
'input logic [3:0]	wstrb_to_apb_i;',
'input logic [31:0]	wdata_to_apb_i;	',
'input logic [31:0]	start_addr_i;',
'input logic [7:0]	len_of_burst_i;',
'input logic [2:0] 	size_of_transfer_i;',
'input logic [1:0]	used_burst_i;',
'input logic [2:0]	used_prot_i;',
'//',
'output logic [31:0]             paddr;',
'output logic [2:0]              pprot;',
'output logic [`SLAVE_CNT-1:0]   psel;',
'output logic                    penable;',
'output logic                    pwrite;',
'output logic [31:0]             pwdata;',
'output logic [3:0]              pstrb;',
'input  logic [`SLAVE_CNT-1:0][31:0] prdata;',
'input  logic [`SLAVE_CNT-1:0]   pready;',
'input  logic [`SLAVE_CNT-1:0]   pslverr;',
'//send to AXI transaction controller',
'output logic [31:0] prdataX_o;',
'output logic pslverrX_o;',
'//control outputs',
'output logic	write_to_rd_sfifo_o;',
'output logic	read_from_wd_sfifo_o;',
'output logic 	set_up_phase_o;',
'output logic	beat_cnt_incr_o;',
'output logic 	dec_error_o;',
'output logic 	latch_resp_o;',
'//*********************************************************',
'//INTERNAL VARIABLES',
'//*********************************************************',
'//psel register',
' logic false_psel_reg, true_psel_reg;',
'//apb transfer address',
'  logic [31:0]                    next_addr_for_incr;',
'  logic [31:0]                    next_addr_for_wrap;',
'  logic [2:0]                     bit_num;',
'  logic [2:0]                     bit3Addr;',
'  logic [3:0]                     bit4Addr;',
'  logic [4:0]                     bit5Addr;',
'  logic [5:0]                     bit6Addr;',
'  //abp address control',
'  logic addr_incr_en;',
'  logic begin_transfer;',
'  //DECODER signals',
'  logic [`SLAVE_CNT-1:0] true_psel;',
'  logic false_psel;',
'  logic preadyX;',
'  logic error_of_decoder;',
'  //APB FMS output',
'  logic invalid_psel;',
'  //APB state',
'//APB state machine',
'typedef enum logic [1:0] {P_IDLE, SETUP, ACCESS} apb_st;',
'  apb_st apb_cs, apb_ns;',
'  //',
'  //APB state regs',
'  //',
'  always_ff @(posedge pclk, negedge preset_n) begin',
'    if(~preset_n)',
'	  apb_cs[1:0] &lt;= P_IDLE;',
'	else',
'	  apb_cs[1:0] &lt;= apb_ns[1:0];',
'  end',
'//',
'//',
'//',
'  always_comb begin',
'	apb_ns = apb_cs;',
'	pprot = 0;',
'	psel = 0;',
'	invalid_psel = 0;',
'	penable = 0;',
'	pwrite = 0;',
'	pwdata = 0;',
'	pstrb = 0;',
'	set_up_phase_o = 1\'b0;',
'	write_to_rd_sfifo_o = 1\'b0;',
'	latch_resp_o = 1\'b0;',
'	beat_cnt_incr_o = 1\'b0;',
'	read_from_wd_sfifo_o = 1\'b0;',
'	addr_incr_en = 1\'b0;',
'	//',
'    case(apb_cs[1:0])',
'		P_IDLE: begin',
'			if(next_transfer_rdy_i) begin',
'				apb_ns[1:0] = SETUP;',
'			end',
'			else',
'			apb_ns[1:0] = P_IDLE;',
'		end',
'		SETUP: begin',
'			apb_ns[1:0] = ACCESS;',
'			psel = true_psel_reg;',
'			invalid_psel = false_psel_reg;',
'			penable = 1\'b0;',
'			pwrite = (grant_to_write_i) ? 1\'b1: 1\'b0;',
'			pwdata = (grant_to_write_i) ? wdata_to_apb_i[31:0] : 32\'d0;',
'		    pstrb[3:0] = (grant_to_write_i) ? wstrb_to_apb_i[3:0] : 4\'h0;',
'		    	set_up_phase_o = 1\'b1;',
'		end',
'		ACCESS: begin',
'			pprot[2:0] = used_prot_i;',
'			psel = true_psel_reg;',
'			invalid_psel = false_psel_reg;',
'			penable = 1\'b1;',
'			pwrite = (grant_to_write_i) ? 1\'b1: 1\'b0;',
'			pwdata = (grant_to_write_i) ? wdata_to_apb_i[31:0] : 32\'d0;',
'		    pstrb[3:0] = (grant_to_write_i) ? wstrb_to_apb_i[3:0] : 4\'h0;',
'			//',
'			if(preadyX) begin',
'				write_to_rd_sfifo_o = 1\'b1;',
'				latch_resp_o = (grant_to_write_i) ? 1\'b1 : 1\'b0;',
'				beat_cnt_incr_o = 1\'b1;',
'				read_from_wd_sfifo_o = 1\'b1;',
'				//',
'				if(next_transfer_rdy_i) begin',
'					apb_ns[1:0] = SETUP;',
'					addr_incr_en = 1\'b1;',
'				end',
'				else begin',
'					apb_ns[1:0] = P_IDLE;',
'					addr_incr_en = end_of_burst_i ? 1\'b0 : 1\'b1;',
'				end',
'			end //end of preadyX',
'			else begin',
'				apb_ns[1:0] = ACCESS;',
'			end',
'		end',
'		default: begin',
'			apb_ns[1:0] = P_IDLE;',
'			pprot = 0;',
'			psel = 0;',
'			invalid_psel = 0;',
'			penable = 0;',
'			pwrite = 0;',
'			pwdata = 0;',
'			pstrb = 0;',
'			set_up_phase_o = 1\'b0;',
'			write_to_rd_sfifo_o = 1\'b0;',
'			latch_resp_o = 1\'b0;',
'			beat_cnt_incr_o = 1\'b0;',
'			read_from_wd_sfifo_o = 1\'b0;',
'			addr_incr_en = 1\'b0;',
'		end',
'	endcase',
'  end',
'//',
'//psel register',
'//',
'always@(posedge pclk, negedge preset_n) begin',
' if(~preset_n) begin',
'	 true_psel_reg &lt;= {`SLAVE_CNT{1\'b0}};',
'	 false_psel_reg &lt;= 1\'b0;',
' end',
' else begin',
'	 true_psel_reg &lt;= true_psel;',
'	 false_psel_reg &lt;= false_psel;',
' end',
'end',
'//',
'//paddr',
'//',
'always_ff @(posedge pclk, negedge preset_n) begin',
'if(~preset_n) begin',
'  paddr[31:0] &lt;= 32\'d0;',
'end',
'else begin',
'	if(true_psel) begin //valid_transfer',
'		if(begin_transfer) paddr[31:0] &lt;= {start_addr_i[31:2], 2\'b00};',
'		else begin',
'			if(addr_incr_en) begin',
'				case(used_burst_i[1:0])',
'				2\'b00:  paddr[31:0] &lt;= paddr[31:0]; //FIXED ',
'				2\'b01:  begin //INCR',
'					paddr[31:0] &lt;= next_addr_for_incr[31:0];',
'				end',
'				2\'b10:  begin //WRAP',
'					paddr[31:0] &lt;= next_addr_for_wrap[31:0];',
'				end',
'				default: paddr[31:0] &lt;= 32\'d0;',
'				endcase',
'			end //end of if addr_incr_en',
'			else begin',
'				paddr[31:0] &lt;= paddr[31:0];',
'			end',
'		end',
'	end//end of valid_transfer',
'	else begin',
'		paddr[31:0] &lt;= 32\'d0;',
'	end',
'end//end of else presetn',
'end',
'//',
'assign next_addr_for_incr[31:0] = paddr[31:0] + 3\'d4;',
'    //',
'  //bit_num',
'  always_comb begin',
'    case(len_of_burst_i[7:0])',
'	  8\'d1:  bit_num[2:0] = 3\'b011;',
'	  8\'d3:  bit_num[2:0] = 3\'b100;',
'	  8\'d7:  bit_num[2:0] = 3\'b101;',
'	  8\'d15: bit_num[2:0] = 3\'b110;',
'	  default: bit_num[2:0] = 3\'bx;',
'	endcase',
'  end',
'  //bit3Addr, bit4Addr, bit5Addr, bit6Addr',
'  always_comb begin',
'    if(bit_num[2:0] == 3\'b011)',
'	  bit3Addr[2:0] = paddr[2:0] + 3\'d4;',
'	else',
'	  bit3Addr[2:0] = 3\'d0;',
'  end',
'  always_comb begin',
'    if(bit_num[2:0] == 3\'b100)',
'	  bit4Addr[3:0] = paddr[3:0] + 3\'d4;',
'	else',
'	  bit4Addr[3:0] = 4\'d0;',
'  end',
'  always_comb begin',
'    if(bit_num[2:0] == 3\'b101)',
'	  bit5Addr[4:0] = paddr[4:0] + 3\'d4;',
'	else',
'	  bit5Addr[4:0] = 5\'d0;',
'  end',
'  always_comb begin',
'    if(bit_num[2:0] == 3\'b110)',
'	  bit6Addr[5:0] = paddr[5:0] + 3\'d4;',
'	else',
'	  bit6Addr[5:0] = 6\'d0;',
'  end',
'  //next_addr_for_wrap',
'  always_comb begin',
'    case(bit_num[2:0])',
'	  3\'b011: next_addr_for_wrap[31:0] = {paddr[31:3], bit3Addr[2:0]};',
'	  3\'b100: next_addr_for_wrap[31:0] = {paddr[31:4], bit4Addr[3:0]};',
'	  3\'b101: next_addr_for_wrap[31:0] = {paddr[31:5], bit5Addr[4:0]};',
'	  3\'b110: next_addr_for_wrap[31:0] = {paddr[31:6], bit6Addr[5:0]};',
'	  default: next_addr_for_wrap[31:0] = 32\'bx;',
'	endcase',
'  end',
'  //dec error register',
'  always_ff@(posedge pclk, negedge preset_n) begin',
'	  if(~preset_n) dec_error_o &lt;= 1\'b0;',
'	  else if(begin_transfer) dec_error_o &lt;= error_of_decoder;',
'  end',
'  //',
'RiSiEdgeDetector RiSiEdgeDetector_trans_go(',
'  .clk_i(pclk),',
'  .rstn_i(preset_n),',
'  .sign_i(trans_go_i),',
'  .red_o(begin_transfer)  ',
'  //',
');',
'//',
'//DECODER ',
'//',
'decoder decoder_inst(',
'	.start_addr_i(start_addr_i),',
'	.size_of_transfer_i(size_of_transfer_i),',
'	.used_burst_i(used_burst_i),',
'	//',
'	.invalid_psel_i(invalid_psel),',
'	.psel(psel),',
'	.pready(pready),',
'	.pslverr(pslverr),',
'	.prdata(prdata),',
'	//',
'	.preadyX_o(preadyX),',
'	.pslverrX_o(pslverrX_o),',
'	.prdataX_o(prdataX_o),',
' 	.dec_error_o(error_of_decoder),',
'	.true_psel_o(true_psel),',
'	.false_psel_o(false_psel)',
'	//',
'	//',
'	//',
');',
'',
'endmodule',
''
];
countinueBuildStmtTable(g_sourceLines);
